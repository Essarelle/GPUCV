<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>GpuCV: Creating a GpuCV operator - using OpenGL and GLSL -</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="twiki_style.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
</div>
<div class="contents">


<h1><a class="anchor" id="TUTO_CREATE_OP_GLSL">Creating a GpuCV operator - using OpenGL and GLSL - </a></h1><h2><a class="anchor" id="TUTO_CREATE_OP_GLSL__SCT_INTRO">
Intro</a></h2>
<dl class="user"><dt><b>PRE-REQUIS</b></dt><dd><ul>
<li>
<a class="el" href="TUTO_CREATE_OP_BASE.html">Creating a GpuCV operator - base concept -</a> </li>
<li>
Basic GLSL programming </li>
</ul>
</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd></dd></dl>
<dl class="author"><dt><b>Author:</b></dt><dd>Yannick Allusse </dd></dl>
<dl class="version"><dt><b>Version:</b></dt><dd>GpuCV v0.4.2 rev 487 </dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Turorial tag: <b>TUTO_CREATE_OP_GLSL_TAG</b></dd></dl>
<p><br/>
In this tutorial, we will describe how to create a simple arithmetics operators using templates functions supply by GpuCV and GLSL language ( ex:Add). Theses templates are used to declare arithmetic operators for any kind of input, output, and channels number. <br/>
<br/>
Follow the key tag <b>TUTO_CREATE_OP_GLSL_TAG*</b> in full project source code to have the correspondance of each steps: </p>
<ol>
<li>
<a class="el" href="TUTO_CREATE_OP_GLSL.html#TUTO_CREATE_OP_GLSL__STP1__LAUNCHER">Writing the operator launcher</a> </li>
<li>
<a class="el" href="TUTO_CREATE_OP_GLSL.html#TUTO_CREATE_OP_BASE__STP2__WRITE_SHADER">Writing the shader programs</a> <ol>
<li>
<a class="el" href="TUTO_CREATE_OP_GLSL.html#TUTO_CREATE_OP_BASE__STP2__WRITE_SHADER_HEADER">Shader file header</a> </li>
<li>
<a class="el" href="TUTO_CREATE_OP_GLSL.html#TUTO_CREATE_OP_BASE__STP2__WRITE_SHADER_BODY">Shader file body</a> </li>
</ol>
</li>
<li>
<a class="el" href="TUTO_CREATE_OP_GLSL.html#TUTO_CREATE_OP_GLSL__STP3__RENDER_2_TEXTURE">OpenGL rendering to a texture/IplImage</a> </li>
</ol>
<dl class="user"><dt><b>Files to edit</b></dt><dd>First, open/create the corresponding file: <ul>
<li>
src/GPUCV/cxcoreg.[cpp/h] for a <b>cxcore</b> operator </li>
<li>
src/GPUCV/cvg.[cpp/h] for a <b><a class="el" href="namespacecv.html">cv</a></b> operator </li>
<li>
src/GPUCV/cvaux.[cpp/h] for a <b>cvaux</b> operator </li>
<li>
src/GPUCV/custom.[cpp/h] for a <b>user custom</b> operator </li>
</ul>
And the corresponding shader files: <ul>
<li>
bin/FShader/NEW_SHADER.frag for fragment shader </li>
<li>
bin/VShader/NEW_SHADER.vert for vertex shader </li>
<li>
bin/GShader/NEW_SHADER.geo for geometry shader </li>
</ul>
</dd></dl>
<h2><a class="anchor" id="TUTO_CREATE_OP_GLSL__STP1__LAUNCHER">
Writing the operator launcher</a></h2>
<p><em>Tag:</em> <b>TUTO_CREATE_OP_GLSL_TAG__STP1__LAUNCHER</b><br/>
 The first step of creating a operator launcher is to define all the data and parameters that the filter requires to execute. Then we makes sure they are acceptable/compatible by/with the filter. <br/>
 <br/>
GpuCV supplies a useful generic function to call most of the shader based operators: <a class="el" href="group__GPUCV__SHADER__GRP.html#gac8a038c86ff6c07e0ef18cfee76fbfaa">TemplateOperator()</a> <br/>
It loads data to GPU if required, performs extra control, execute the given shader and return data to cpu if required. <br/>
 <br/>
Let's have a look at all the parameters required: </p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> <a class="code" href="group__GPUCV__SHADER__GRP.html#gac8a038c86ff6c07e0ef18cfee76fbfaa">TemplateOperator</a>   (       
        std::string     _fctName,                       <span class="comment">//name of the C++ current function</span>
        std::string     _filename1,                     <span class="comment">//path and name of the fragment shader program file(without the .frag)</span>
        std::string     _filename2,                     <span class="comment">//path and name of the vertex shader program file(without the .vert), here we will use the default vertex shader, no need to specify one.</span>
        CvArr *                 _src1,                  <span class="comment">//input image one</span>
        CvArr *                 _src2,                  <span class="comment">//input image two</span>
        CvArr *                 _src3,                  <span class="comment">//input image three</span>
        CvArr *                 _dest,                  <span class="comment">//destination image</span>
        <span class="keyword">const</span> <span class="keywordtype">float</span> *   _params,                        <span class="comment">//array of optional parameters</span>
        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>    _param_nbr,                     <span class="comment">//nomber of parmeters</span>
        TextureGrp::TextureGrp_CheckFlag        _controlFlag,           <span class="comment">//Optional control flags on input/ouput data</span>
        std::string     _optionalMetaTag,       <span class="comment">//Optional meta-tag to generate meta-shaders</span>
        FCT_PTR_DRAW_TEXGRP(_DrawFct)                   <span class="comment">//custom drawing function is used for advenced operators and will be explain in another tutorial.               </span>
        )       
</pre></div><p>The following subsections describes several cases of the 'addition' example.</p>
<dl class="user"><dt><b>Add two images</b></dt><dd>First case of the 'addition': adding two images <div class="fragment"><pre class="fragment">        <a class="code" href="group__GPUCV__SHADER__GRP.html#gac8a038c86ff6c07e0ef18cfee76fbfaa">TemplateOperator</a>(
                <span class="stringliteral">&quot;cvgAdd&quot;</span>,                       <span class="comment">//name of the launcher function</span>
                <span class="stringliteral">&quot;FShaders/add&quot;</span>,         <span class="comment">//name of the fragment shader program file we want to use</span>
                <span class="stringliteral">&quot;&quot;</span>,                                     <span class="comment">//using default vertex program</span>
                src1,                   
                src2,
                NULL,                           <span class="comment">//no mask</span>
                dst,                            <span class="comment">//destination image</span>
                NULL,                           <span class="comment">//no parameters</span>
                0,                      
                TextureGrp::TEXTGRP_SAME_SIZE,  <span class="comment">//all image should have the same size</span>
                <span class="stringliteral">&quot;&quot;</span>,                             
                NULL
        );
</pre></div> This is enought to call our filter.</dd></dl>
<dl class="user"><dt><b>Add two images using a mask</b></dt><dd>Second case of the 'addition': adding two images using a mask <div class="fragment"><pre class="fragment">        <a class="code" href="group__GPUCV__SHADER__GRP.html#gac8a038c86ff6c07e0ef18cfee76fbfaa">TemplateOperator</a>(
                <span class="stringliteral">&quot;cvgAdd&quot;</span>,                       <span class="comment">//name of the launcher function</span>
                <span class="stringliteral">&quot;FShaders/add_mask&quot;</span>,            <span class="comment">//name of the fragment shader program file we want to use</span>
                <span class="stringliteral">&quot;&quot;</span>,                                     <span class="comment">//using default vertex program</span>
                src1,                   
                src2,
                mask,                           <span class="comment">//*mask*</span>
                dst,                            <span class="comment">//destination image</span>
                NULL,                           <span class="comment">//no parameters</span>
                0,                      
                TextureGrp::TEXTGRP_SAME_SIZE,  <span class="comment">//all image should have the same size</span>
                <span class="stringliteral">&quot;&quot;</span>,                             
                NULL
        );
</pre></div> This is enought to call our filter using a mask.</dd></dl>
<dl class="user"><dt><b>Add one image and one scalar</b></dt><dd>Third case of the 'addition': adding one images with one scalar value <div class="fragment"><pre class="fragment">        <span class="keywordtype">float</span> Params[4];
        ...<span class="comment">//copy scalar values into Params</span>
        
        <a class="code" href="group__GPUCV__SHADER__GRP.html#gac8a038c86ff6c07e0ef18cfee76fbfaa">TemplateOperator</a>(
                <span class="stringliteral">&quot;cvgAdd&quot;</span>,                       <span class="comment">//name of the launcher function</span>
                <span class="stringliteral">&quot;FShaders/add_scalar&quot;</span>,          <span class="comment">//name of the fragment shader program file we want to use</span>
                <span class="stringliteral">&quot;&quot;</span>,                                     <span class="comment">//using default vertex program</span>
                src1,                   
                NULL,                           <span class="comment">//*no second input image*</span>
                NULL,                           <span class="comment">//no mask</span>
                dst,                            <span class="comment">//destination image</span>
                Params,                         <span class="comment">//*Parameters pointer*</span>
                4,                                      <span class="comment">//*Parameters number*</span>
                TextureGrp::TEXTGRP_SAME_SIZE,  <span class="comment">//all image should have the same size</span>
                <span class="stringliteral">&quot;&quot;</span>,                             
                NULL
        );
</pre></div> This is enought to call our filter using a scalar parameter.</dd></dl>
<dl class="user"><dt><b>Add one image and one scalar using a mask</b></dt><dd>Third case of the 'addition': adding one images with one scalar value <div class="fragment"><pre class="fragment">        <span class="keywordtype">float</span> Params[4];
        ...<span class="comment">//copy scalar values into Params</span>
        
        <a class="code" href="group__GPUCV__SHADER__GRP.html#gac8a038c86ff6c07e0ef18cfee76fbfaa">TemplateOperator</a>(
                <span class="stringliteral">&quot;cvgAdd&quot;</span>,                       <span class="comment">//name of the launcher function</span>
                <span class="stringliteral">&quot;FShaders/add_scalar&quot;</span>,          <span class="comment">//name of the fragment shader program file we want to use</span>
                <span class="stringliteral">&quot;&quot;</span>,                                     <span class="comment">//using default vertex program</span>
                src1,                   
                mask,                           <span class="comment">//*second became mask image*</span>
                NULL,                           <span class="comment">//</span>
                dst,                            <span class="comment">//destination image</span>
                Params,                         <span class="comment">//Parameters pointer</span>
                4,                                      <span class="comment">//Parameters number</span>
                TextureGrp::TEXTGRP_SAME_SIZE,  <span class="comment">//all image should have the same size</span>
                <span class="stringliteral">&quot;&quot;</span>,                             
                NULL
        );
</pre></div> This is enought to call our filter using a scalar parameter with mask.</dd></dl>
<h2><a class="anchor" id="TUTO_CREATE_OP_BASE__STP2__WRITE_SHADER">
Writing the shader programs</a></h2>
<dl class="note"><dt><b>Note:</b></dt><dd>GpuCV currently only accepts GLSL shader code. This section will explain you how to write shader program for GpuCV but will not explain you what is a shader and how it works. You should already have some 'really basic' knownledge of shader programming. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a href="http://oss.sgi.com/projects/ogl-sample/registry/ARB/GLSLangSpec.Full.1.10.59.pdf" target="blank">GLSL specifications</a>, <a href="http://www.lighthouse3d.com/opengl/glsl/index.php?shaders" target="blanck">GLSL tutorial</a>. <em>Tag:</em> <b>TUTO_CREATE_OP_BASE_TAG__STP2__WRITE_SHADER</b><br/>
 A shader program can be: <ol>
<li>
A fragment or pixel shader (.frag): is executed for each pixels of the framebuffer. </li>
<li>
A vertex shader (.vert): is executed for each vertex of the geometry, most GpuCV operator will used default vertex shader. </li>
<li>
A geometry shader (.geo): (not yet available in GpuCV) is executed to generate geometry. </li>
</ol>
</dd></dl>
<p>GpuCV supply some tools to hide some of the shader complexity so you do not need to be expert with GLSL. Let's have a look at the base structure of a fragment shader. All shader files should be saved into the default shader paths ("bin\FShader\", "bin\VShader\").</p>
<h3><a class="anchor" id="TUTO_CREATE_OP_BASE__STP2__WRITE_SHADER_HEADER">
Shader file header</a></h3>
<p>You will find the following references inside the definitions </p>
<ul>
<li>
License </li>
<li>
Fragment name or function description </li>
<li>
'CVG_METASHADERBegin' and 'CVG_METASHADEREnd' tags. They are used to automatically update the code inside them. So don't remove them. </li>
<li>
<p class="startli">Inside the previous tags there is automatic meta-shaders defines values([MORE_HERE]=&gt;link to metashaders): </p>
<ul>
<li>
GETTEX is a macro to get pixel from the texture[texture2D|textureRect] </li>
<li>
IMGTYPE is a macro to define the type of the texture[uniform sampler2D|uniform samplerRect] </li>
<li>
GPUCV_FILTER is a flag to define if this filter is used inside GpuCV or from an external shader compiler. </li>
</ul>
<p><br/>
See ShaderObject::ParseFilename() for more details on meta-shaders.</p>
<p class="endli"></p>
</li>
<li>
'IMGTYPE BaseImage' define the source image 1. </li>
<li>
'IMGTYPE Image0' define the source image 2, not required for every shaders. </li>
<li>
'IMGTYPE ImageX' define the source image X if more than 2 images. </li>
<li>
'uniform float[n]' define the table of n parameters, n must correspond to the paramNbr given to <a class="el" href="group__GPUCV__SHADER__GRP.html#gac8a038c86ff6c07e0ef18cfee76fbfaa">TemplateOperator()</a>. </li>
</ul>
<dl class="warning"><dt><b>Warning:</b></dt><dd>You have to respect this synthaxe, otherwise your shaders will not be compatible with the library. </dd>
<dd>
Only one shader program per file.</dd></dl>
<dl class="user"><dt><b>Default header</b></dt><dd><div class="fragment"><pre class="fragment">        <span class="comment">/*License terms</span>
<span class="comment">        ....*/</span>
        <span class="comment">//Add Fragment Shader</span>
        <span class="comment">//CVG_METASHADERBegin</span>
<span class="preprocessor">        #define GETTEX //function to get texture value</span>
<span class="preprocessor"></span><span class="preprocessor">        #define IMGTYPE //texture type</span>
<span class="preprocessor"></span>        <span class="comment">//---------------------CVG_METASHADEREnd</span>
        IMGTYPE BaseImage; <span class="comment">// source imag</span>
        ...<span class="comment">//custom values</span>
</pre></div></dd></dl>
<dl class="user"><dt><b>Add two images</b></dt><dd><div class="fragment"><pre class="fragment">        ...<span class="comment">//Default header</span>
        IMGTYPE Image0;    <span class="comment">// second image</span>
</pre></div></dd></dl>
<dl class="user"><dt><b>Add two images using a mask</b></dt><dd><div class="fragment"><pre class="fragment">        ...<span class="comment">//Default header</span>
        IMGTYPE Image0;    <span class="comment">// second image</span>
        IMGTYPE Image1;    <span class="comment">// mask image</span>
</pre></div></dd></dl>
<dl class="user"><dt><b>Add one image with scalar</b></dt><dd><div class="fragment"><pre class="fragment">        ...<span class="comment">//Default header</span>
        uniform <span class="keywordtype">float</span> Params[4];        <span class="comment">//scalar of 4 float</span>
</pre></div> </dd></dl>
<dl class="user"><dt><b>Add one image with scalar using a mask</b></dt><dd><div class="fragment"><pre class="fragment">        ...<span class="comment">//Default header</span>
        uniform <span class="keywordtype">float</span> Params[4];        <span class="comment">//scalar of 4 float</span>
        IMGTYPE Image0;         <span class="comment">// mask image</span>
</pre></div></dd></dl>
<h3><a class="anchor" id="TUTO_CREATE_OP_BASE__STP2__WRITE_SHADER_BODY">
Shader file body</a></h3>
<dl class="user"><dt><b>Add two images</b></dt><dd>Here is the <a class="el" href="group__GPUCV__SIMPLEAPP__GRP.html#ga3c04138a5bfe5d72780bb7e82a18e627">main()</a> body of an 'addition' with two images. <div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> <a class="code" href="group__GPUCV__SIMPLEAPP__GRP.html#ga3c04138a5bfe5d72780bb7e82a18e627">main</a>(<span class="keywordtype">void</span>)
{
        <span class="comment">//get current pixels values from each textures.</span>
    vec4 img1 = GETTEX(BaseImage, gl_TexCoord[0].st).rgba;
        vec4 img2 = GETTEX(Image0, gl_TexCoord[0].st).rgba;
        <span class="comment">//apply the operators</span>
        gl_FragColor = vec4(img1 + img2);
}
</pre></div></dd></dl>
<dl class="user"><dt><b>Add two images using a mask</b></dt><dd><div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> <a class="code" href="group__GPUCV__SIMPLEAPP__GRP.html#ga3c04138a5bfe5d72780bb7e82a18e627">main</a>(<span class="keywordtype">void</span>)
{
    vec4 img1 = GETTEX(BaseImage, gl_TexCoord[0].st).rgba;
    vec4 mask = GETTEX(Image1, gl_TexCoord[0].st).rgba;
    <span class="keywordflow">if</span>(mask.r!=0)
        {
                vec4 img2 = GETTEX(Image0, gl_TexCoord[0].st).rgba;
                gl_FragColor = vec4(img1 + img2);
        }
        <span class="keywordflow">else</span>
                gl_FragColor = img1;
}
</pre></div></dd></dl>
<dl class="user"><dt><b>Add one image with scalar</b></dt><dd><div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> <a class="code" href="group__GPUCV__SIMPLEAPP__GRP.html#ga3c04138a5bfe5d72780bb7e82a18e627">main</a>(<span class="keywordtype">void</span>)
{
    vec4 img1 = GETTEX(BaseImage, gl_TexCoord[0].st).rgba;
    vec4 img2 = vec4(Params[0], Params[1], Params[2], Params[3]);
    gl_FragColor = vec4(img1 + img2);
}
</pre></div></dd></dl>
<dl class="user"><dt><b>Add one image with scalar using a mask</b></dt><dd><div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> <a class="code" href="group__GPUCV__SIMPLEAPP__GRP.html#ga3c04138a5bfe5d72780bb7e82a18e627">main</a>(<span class="keywordtype">void</span>)
{
    vec4 img1 = GETTEX(BaseImage, gl_TexCoord[0].st).rgba;
        vec4 mask = GETTEX(Image1, gl_TexCoord[0].st).rgba;
    <span class="keywordflow">if</span>(mask.r!=0)
        {
                vec4 img2 = vec4(Params[0], Params[1], Params[2], Params[3]);
                gl_FragColor = vec4(img1 + img2);
        }
        <span class="keywordflow">else</span>
                gl_FragColor = img1;
}
</pre></div></dd></dl>
<h2><a class="anchor" id="TUTO_CREATE_OP_GLSL__STP3__RENDER_2_TEXTURE">
OpenGL rendering to a texture/IplImage</a></h2>
<p>One of the main mechanism used in OpenGL based GPGPU applications is rendering to texture. GpuCV use it to render the result of a GLSL shader to the target image/texture. It is also possible to render some OpenGL functions directly to a texture without using shader (see previous section). IplImage is the base format to manage images in OpenCV. You can use the high-level solution that manage all the OpenCV/GpuCV interactions (might be a bit slower) or get a pointer to the corresponding CvgArr pointer to have a closer control.</p>
<h3><a class="anchor" id="TUTO_CREATE_OP_GLSL__STP3__RENDER_2_TEXTURE__IPLIMAGES">
Using IplImages(high-level)</a></h3>
<div class="fragment"><pre class="fragment"><span class="comment">//..we have an IplImage * named Ipl_GLDest.</span>
<a class="code" href="group__CVG__MISC__GRP.html#gafc601e307a52a195f9b8011f7e7209b7">cvgSetRenderToTexture</a>(Ipl_GLDest);<span class="comment">// start rendering to Ipl_GLDest</span>
<a class="code" href="group__CVG__MISC__GRP.html#gacf816b75d7ee18df87f09ef0b368e309">cvgInitGLView</a>(Ipl_GLDest);<span class="comment">// init OpenGL viewport using the Ipl_GLDest image properties (size,...)</span>
<span class="comment">//..</span>
<span class="comment">//.. here, place your OpenGL drawing code..</span>
<span class="comment">//..</span>
<a class="code" href="group__CVG__MISC__GRP.html#ga65c98f1e1d12ea207b6f7781ffcaa6a9">cvgUnsetRenderToTexture</a>(Ipl_GLDest);<span class="comment">// stop rendering to Ipl_GLDest</span>
<span class="comment">// rendering is done...</span>
<span class="comment">// if you want your data back to CPU, ask for synchronization</span>
<a class="code" href="group__CVG__MISC__GRP.html#ga48e1062f70a6a18a36014e119f92abda" title="Synchronize CvArr image between CPU and GPU, it makes sure the data are on CPU.">cvgSynchronize</a>(Ipl_GLDest);
</pre></div><dl class="note"><dt><b>Note:</b></dt><dd>This method might be slower due to some wrapping and testing code into each funcions (<a class="el" href="group__CVG__MISC__GRP.html#gafc601e307a52a195f9b8011f7e7209b7">cvgSetRenderToTexture()</a>/cvgInitGLView()/cvgUnsetRenderToTexture()) used to retrieve the corresponding CvgArr from the IplImage. </dd>
<dd>
Use this method if you have a 'C' application.</dd></dl>
<h3><a class="anchor" id="TUTO_CREATE_OP_GLSL__STP3__RENDER_2_TEXTURE__CVGARR">
Using CvgArr and the OpenGL data descriptor DataDsc_GLTex(middle-level)</a></h3>
<p>CvgArr is the GpuCV corresponding format to OpenCV IplImages, it unherits from class DataContainer. DataContainer can contains several instances of the image of different types. We will use the DataDsc_GLTex type which manage interactions between GpuCV and OpenGL textures.</p>
<div class="fragment"><pre class="fragment"><span class="comment">//..we have an IplImage * named Ipl_GLDest.</span>
<span class="comment">//..we need the corresponding CvgArr named CvgArr_GLDest.</span>
DataContainer * CvgArr_GLDest           = GPUCV_GET_TEX(Ipl_GLDest);
SG_Assert(CvgArr_GLDest, <span class="stringliteral">&quot;No CvgArr for Ipl_GLDest.&quot;</span>);<span class="comment">// test result.</span>
<span class="comment">//..now we need the OpenGL texture data descriptor DataDsc_GLTex named DDGL_GLDest.</span>
DataDsc_GLTex * DDGL_GLDest             = CvgArr_GLDest-&gt;GetDataDesc&lt;DataDsc_GLTex&gt;();
SG_Assert(DDGL_GLDest, <span class="stringliteral">&quot;No DataDsc_GLTex for CvgArr.&quot;</span>); <span class="comment">// test result.</span>

DDGL_GLDest-&gt;SetRenderToTexture();              <span class="comment">// start rendering to DDGL_GLDest</span>
DDGL_GLDest-&gt;InitGLView();
<span class="comment">//..</span>
<span class="comment">//.. here, place your OpenGL drawing code..</span>
<span class="comment">//..</span>

DDGL_GLDest-&gt;UnsetRenderToTexture();            <span class="comment">// stop rendering to DDGL_GLDest</span>
<span class="comment">// rendering is done...</span>

<span class="comment">// if you want your data back to CPU, ask for synchronization</span>
<span class="comment">// we ask the DataContainer to copy data back to CPU, in our case CPU data are managed by the data descriptor DataDesc_CPU.</span>
<span class="comment">// the bool flag is to enable data transfer.</span>
CvgArr_GLDest-&gt;SetLocation&lt;DataDsc_CPU&gt;(<span class="keyword">true</span>);
</pre></div><dl class="note"><dt><b>Note:</b></dt><dd>Any memory allocation are done by the functions SetRenderToTexture() for the OpenGL texture or by SetLocation&lt;DataDsc_CPU&gt;() for the IplImage buffer only if required. </dd></dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Be aware that you should not call any functions to swap OpenGL frame buffers between SetRenderToTexture() and UnsetRenderToTexture().</dd></dl>
<p>Now you have written your first GpuCV operator, go to section <a class="el" href="TUTO_TEST_OP.html">Testing and benchmarking a GpuCV operator</a> to try and benchmark it.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>As you can see, a quite simple 'addition' filter might require 4 different files, one for each case. Having to many shader files can become confusing for developpers and users and hard to maintain up to date. The use of meta-shader can reduce significantly the number file involved, continue to next tutorial. </dd></dl>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Friends</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr size="1">
<table border="0" width="100%">
<tr>
<td>
Retrieve latest informations, releases and documentation on <a href="https://picoforge.int-evry.fr/cgi-bin/twiki/view/Gpucv/Web/WebHome">GpuCV website</a>.
</td>
<td width ="50">
</td>
<td>
<address style="text-align: right;"><small>Generated
on Wed Oct 22 20:37:13 2008 for <a href="https://picoforge.int-evry.fr/cgi-bin/twiki/view/Gpucv/Web/WebHome">GpuCV</a> by&nbsp;
<a href="http://www.doxygen.org/index.html"><img
 src="doxygen.png" alt="doxygen" align="middle"
 border="0"></a> 1.5.4 </small></address>
 </td>
 </tr>
 </table>
