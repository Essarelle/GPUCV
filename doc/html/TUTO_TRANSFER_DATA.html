<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>GpuCV: Transfering data</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="twiki_style.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
</div>
<div class="contents">


<h1><a class="anchor" id="TUTO_TRANSFER_DATA">Transfering data </a></h1><h2><a class="anchor" id="TUTO_CREATE_OP_BASE__SCT_INTRO">
Intro</a></h2>
<dl class="user"><dt><b>PRE-REQUIS</b></dt><dd>NONE. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>DataDsc_Base, DataDsc_GLTex, DataDsc_GLBuff, DataDsc_CPU, DataDsc_IplImage, DataDsc_CvMat, DataDsc_CUDA_Array, DataDsc_CUDA_Buffer </dd></dl>
<dl class="author"><dt><b>Author:</b></dt><dd>Yannick Allusse </dd></dl>
<dl class="version"><dt><b>Version:</b></dt><dd>GpuCV v0.41 rev 233 </dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Turorial tag: <b>TUTO_TRANSFER_DATA</b></dd></dl>
<dl class="user"><dt><b></b></dt><dd>In this tutorial, we will describe how to transfer data between different locations(central memory, graphics memory) and different types (IplImage, CvMat, OpenGL textures, OpenGL Buffers...). <br/>
<br/>
Follow the key tag <b>TUTO_TRANSFER_DATA</b> in full project source code to have the correspondance of each steps: <ol>
<li>
<a class="el" href="TUTO_TRANSFER_DATA.html#TUTO_TRANSFER_DATA__STP1__DATA_LOCATION_ISSUE">The data location issue</a> </li>
<li>
<a class="el" href="TUTO_TRANSFER_DATA.html#TUTO_TRANSFER_DATA__STP2__MECHANISM">GpuCV data managment</a> </li>
<li>
<a class="el" href="TUTO_TRANSFER_DATA.html#TUTO_TRANSFER_DATA__STP3__DATA_DSC_USAGE">Usage</a> </li>
<li>
<a class="el" href="TUTO_TRANSFER_DATA.html#TUTO_TRANSFER_DATA__STP4__DATA_DSC_OPTIONS">Options</a> </li>
<li>
<a class="el" href="TUTO_TRANSFER_DATA.html#TUTO_TRANSFER_DATA__STP5__DEBUGGING">Debugging transfers</a> </li>
</ol>
</dd></dl>
<h2><a class="anchor" id="TUTO_TRANSFER_DATA__STP1__DATA_LOCATION_ISSUE">
The data location issue</a></h2>
<p>GpuCV is using your computer graphics card to perform image and data processing. This means that the library needs to have a local copy of all the data to be processed in video memory, sometime resulting in having 2 instances or more of the same data in different memories: </p>
<ul>
<li>
in central memory for CPU processing (example: of IplImage and CvMat), <br/>
or/and </li>
<li>
in graphics memory for GPU processing (example: OpenGL texture or buffer, CUDA buffer or array...). </li>
</ul>
<p><br/>
GpuCV uses CvgArr object as a container for CvArr structure and image data. When a GpuCV function is called, the library checks in which location(s) the image data are available and transfers the image data where they are required. Holding two instances of data can imply data inconsistency and synchronization issues, due to the fact that OpenCV is not aware of GpuCV, and GpuCV does not know whether resulting image(s) will be input to some other GpuCV operators or to a native OpenCV operator. To avoid this situations, GpuCV has several mechanisms that we present below.</p>
<dl class="user"><dt><b>The GpuCV approach</b></dt><dd>For OpenCV compatibility purpose, the default behavior of GpuCV operators is to transfer results back to central memory. This guaranties that the result will be a valid OpenCV CvArr. Then data in graphics memory are released to avoid duplicates. This has a cost of loading the graphics port (AGP, PCI-Express...) and a time penalty.</dd></dl>
<dl class="user"><dt><b>Holding CvArr on GPU's memory</b></dt><dd>In case a GpuCV image result is not used by any native OpenCV operator but only by GpuCV operators, this transfer is useless. It can be enabled/disable with functions cvgSetOptions(MY_IMAGE..., DataContainer::CPU_RETURN, true/false).</dd></dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Disabling cpu return options, to a native OpenCV operator will result in an *????????????????*empty buffer error.</dd></dl>
<dl class="user"><dt><b>Allowing duplicates data</b></dt><dd>At some point, you may wish to keep data both in central and graphics memory. This may be useful when an image will be used as a read only image by both GpuCV and OpenCV operators. To avoid unnecessary data transfer you can set the UBIQUITY flag by calling cvgSetOptions(MY_IMAGE..., DataContainer::UBIQUITY, true/false).</dd></dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>To preserve data consistency between duplicates, application developers should disable UBIQUITY flag before changing image data on CPU.</dd></dl>
<h2><a class="anchor" id="TUTO_TRANSFER_DATA__STP2__MECHANISM">
GpuCV data managment</a></h2>
<p>GpuCV framework has been designed to manage any kind of data, in any locations and allows user custom data. It is done by a "Data Container" &lt;-&gt; "Data Descriptor" connections.</p>
<h3><a class="anchor" id="TUTO_TRANSFER_DATA__STP2__SUB1_MECHANISM_CONTAINER">
Data container</a></h3>
<p>A data container is associated with any OpenCV native objects (ex: IplImage, CvMat) and placed into a manager (TextureManager). Theses containers contains one or several data descriptors (DataDsc_Base or unherited class like DataDsc_GLTex or DataDsc_IplImage) and supply functions to manage them. They are also used to store options about the native object and how to manipulate them efficiently.</p>
<h3><a class="anchor" id="TUTO_TRANSFER_DATA__STP2__SUB2_MECHANISM_DSC">
Data descriptors</a></h3>
<p>A data descriptor associates data to a kind of location (ex: central memory or graphics memory) or format (ex: image, matrices...). It contains a precise description of data (type, size, channel number,format, memory used...) and how to copy them to other data descriptors of other kind.</p>
<dl class="user"><dt><b>Available data descriptors</b></dt><dd>All the data descriptors currently available are (organized by unheritence): <ul>
<li>
<p class="startli">DataDsc_Base: </p>
<ul>
<li>
DataDsc_CPU: <ul>
<li>
DataDsc_IplImage </li>
<li>
DataDsc_CvMat </li>
</ul>
</li>
<li>
DataDsc_GLTex </li>
<li>
DataDsc_GLBuff </li>
<li>
DataDsc_CUDA_Base: <ul>
<li>
DataDsc_CUDA_Array </li>
<li>
DataDsc_CUDA_Buffer </li>
</ul>
</li>
</ul>
<p class="endli"></p>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b>Interactions between descriptors</b></dt><dd>They use generic functions to communicate and tansfer data/parameters to each other. Here is a list of the main functions involved into this process:</dd></dl>
<ul>
<li>
DataDsc_Base::TransferFormatFrom(): convert and copy data parameters (type, format, channles...) from the source object to destination using conversion functions: DataDsc_Base::ConvertPixelFormat_GLToLocal(), DataDsc_Base::ConvertPixelFormat_LocalToGL(), DataDsc_Base::ConvertPixelType_GLToLocal(), DataDsc_Base::ConvertPixelType_LocalToGL()<br/>
 </li>
<li>
DataDsc_Base::CopyFrom(): copy data from a source object to current object<br/>
 </li>
<li>
DataDsc_Base::CopyTo(): copy data from local object to a destination object<br/>
 <br/>
 </li>
</ul>
<p><br/>
GpuCV owns several data descriptors, and allow the use of many more. This is due to the function CopyFrom()/CopyTo() that are reimplemented into each object to allow transfer from/to previous type. <br/>
<br/>
Here is a non exaustive list of possible communications: </p>
<ul>
<li>
DataDsc_Base don't own or transfer any data. </li>
<li>
DataDsc_CPU can only tranfer data to/from DataDsc_CPU: it is one of the base type. </li>
<li>
DataDsc_GLTex and DataDsc_GLBuff can tranfer data to/from DataDsc_CPU / DataDsc_GLTex / DataDsc_GLBuff: OpenGL knows how to access central memory and graphics memory. </li>
<li>
DataDsc_CUDA_Array can tranfer data to/from DataDsc_CPU / DataDsc_GLBuff / DataDsc_CUDA_Buffer: CUDA knows how to access central memory and OpenGL buffers. </li>
<li>
DataDsc_CUDA_Buffer can tranfer data to/from DataDsc_CPU / DataDsc_CUDA_Array: CUDA knows how to access central memory and CUDA memory but can't access OpenGL memory. </li>
</ul>
<dl class="note"><dt><b>Note:</b></dt><dd>Every new data descriptors created must know how to transfer its data to/from at least one other existing (internaly in OpenCV) data descriptor object. </dd>
<dd>
Several transfers might be required to transfer from one object to another (ex: transfer between DataDsc_GLTex and DataDsc_CUDA_Array requires to go threw DataDsc_GLBuff).</dd></dl>
<h2><a class="anchor" id="TUTO_TRANSFER_DATA__STP3__DATA_DSC_USAGE">
Usage</a></h2>
<p>GpuCV users and developers can control the data locations and copy at different levels. From an OpenCV applications using cvg* functions or from operators using direct call to data container class (DataContainer / CvgArr).</p>
<h3><a class="anchor" id="TUTO_TRANSFER_DATA__STP3__DATA_DSC_USAGE_CVG">
Data transfer in an OpenCV application</a></h3>
<p>When developing an OpenCV application, data transfer and management is automaticaly managed by the library. Therefore, we supply some function to help you manage specific cases. <br/>
<br/>
 Here is a brief list and description of functions available, please refer to references manual for more details: <br/>
 </p>
<ul>
<li>
<a class="el" href="group__CVG__MISC__GRP.html#ga48e1062f70a6a18a36014e119f92abda" title="Synchronize CvArr image between CPU and GPU, it makes sure the data are on CPU.">cvgSynchronize(CvArr*)</a>: <br/>
Makes sure the given CvArr is on central memory. <br/>
  </li>
<li>
cvgSetLocation&lt;TPL_DTATA_DSC&gt;(CvArr*, bool): <br/>
Attempts to copy of the CvArr to the location given by TPL_DTATA_DSC. <br/>
  </li>
<li>
cvgSetDataFlag&lt;TPL_DTATA_DSC&gt;(CvArr* src, bool _dataFlag, bool _forceUniqueData): <br/>
Changes the data flag of the destination location to _dataFlag, other locations may be affected. <br/>
  </li>
</ul>
<dl class="user"><dt><b>Example 1: load image into an OpenGL texture</b></dt><dd>We want to load an image from a file and transfer it into an OpenGL texture: <div class="fragment"><pre class="fragment">        IplImage * tempImg = cvLoadImage(<span class="stringliteral">&quot;imgTest.jpg&quot;</span>,1);
        <span class="keywordflow">if</span>(tempImg)
        {       <span class="comment">//ask a transfer to GPU</span>
                <span class="comment">//DataDsc_GLTexture is used as a template parameter to the function, it specify the destination</span>
                <span class="comment">//data flag is true so we allocate memory and transfer data</span>
                cvgSetLocation&lt;DataDsc_GLTex&gt;(tempImg, <span class="keyword">true</span>);
        }
        <span class="keywordflow">else</span>
        {
                GPUCV_ERROR(<span class="stringliteral">&quot;Error loading image &quot;</span> &lt;&lt; <span class="stringliteral">&quot;imgTest.jpg&quot;</span> &lt;&lt; <span class="stringliteral">&quot;, the file may not exist...&quot;</span>);
}
</pre></div></dd></dl>
<dl class="user"><dt><b>Example 2: allocate an OpenGL texture</b></dt><dd>We want to allocate video memory so we will be able to write into it later: <div class="fragment"><pre class="fragment">        CvSize size={512, 512};
        IplImage * tempImg = <a class="code" href="group__CVGXCORE__OPER__ARRAY__INIT__GRP.html#ga506088195d94d83e8b7147ceed195c1b" title="GPUCV correspondence of cvCreateImage function. Create one IplImage. You can use...">cvgCreateImage</a>(size, CV_8U, 3);<span class="comment">//create a 3 uchar channels images on CPU</span>
        <span class="keywordflow">if</span>(tempImg)
        {       <span class="comment">//ask to allocate on GPU</span>
                <span class="comment">//DataDsc_GLTexture is used as a template parameter to the function, it specify the destination</span>
                <span class="comment">//data flag is false so we only allocate memory and do not transfer data</span>
                <span class="comment">//tempImg might be used as a destination image later.</span>
                cvgSetLocation&lt;DataDsc_GLTex&gt;(tempImg, <span class="keyword">false</span>);
        }
        <span class="keywordflow">else</span>
        {
                GPUCV_ERROR(<span class="stringliteral">&quot;Error creating image&quot;</span>);
        }
</pre></div></dd></dl>
<dl class="user"><dt><b>Example 3: use of CPU_RETURN option</b></dt><dd></dd></dl>
<dl class="user"><dt><b>Example 3: use of UBIQUITY option</b></dt><dd></dd></dl>
<h3><a class="anchor" id="TUTO_TRANSFER_DATA__STP3__DATA_DSC_USAGE_CLASS">
Data transfer in a GpuCV operator</a></h3>
<p>The class DataContainer and its unherited class (CvgArr) offers more powerful control of data location and transfer. </p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Member functions from DataDsc_base and its unherited class should not be used directly unless you know what you are doing. You should always use DataContainer members. <br/>
<br/>
 Here is a brief list and description of functions available, please refer to references manual for more details: <br/>
 <ul>
<li>
DataContainer::SetLocation&lt;TPL_DTATA_DSC&gt;(bool): <br/>
This function will attempt to make a copy of the CvArr to the location given by TPL_DTATA_DSC. <br/>
  </li>
<li>
DataContainer::SetDataFlag&lt;TPL_DTATA_DSC&gt;(bool _dataFlag, bool _forceUniqueData): <br/>
This function changes the data flag of the destination location to _dataFlag, other locations may be affected. <br/>
  </li>
<li>
DataContainer::GetDataDsc&lt;TPL_DTATA_DSC&gt;(): <br/>
This function return the corresponding data descriptor TPL_DTATA_DSC, it creates it if required. <br/>
  </li>
<li>
DataContainer::RemoveDataDsc&lt;TPL_DTATA_DSC&gt;(): <br/>
This function remove and free the corresponding data descriptor TPL_DTATA_DSC.  <br/>
 </li>
<li>
DataContainer::RemoveAllDataDscExcept&lt;TPL_DTATA_DSC&gt;(): <br/>
This function remove and free all data descriptors except the one specified by TPL_DTATA_DSC. <br/>
  </li>
<li>
DataContainer::SwitchDataDsc&lt;TPL_DTATA_DSC&gt;(DataContainer*): <br/>
This function switch the corresponding data descriptor TPL_DTATA_DSC between two data containers.  </li>
</ul>
</dd></dl>
<h2><a class="anchor" id="TUTO_TRANSFER_DATA__STP4__DATA_DSC_OPTIONS">
Options</a></h2>
<h2><a class="anchor" id="TUTO_TRANSFER_DATA__STP5__DEBUGGING">
Debugging transfers</a></h2>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Friends</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr size="1">
<table border="0" width="100%">
<tr>
<td>
Retrieve latest informations, releases and documentation on <a href="https://picoforge.int-evry.fr/cgi-bin/twiki/view/Gpucv/Web/WebHome">GpuCV website</a>.
</td>
<td width ="50">
</td>
<td>
<address style="text-align: right;"><small>Generated
on Wed Oct 22 20:37:13 2008 for <a href="https://picoforge.int-evry.fr/cgi-bin/twiki/view/Gpucv/Web/WebHome">GpuCV</a> by&nbsp;
<a href="http://www.doxygen.org/index.html"><img
 src="doxygen.png" alt="doxygen" align="middle"
 border="0"></a> 1.5.4 </small></address>
 </td>
 </tr>
 </table>
