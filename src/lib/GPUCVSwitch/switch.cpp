//CVG_LicenseBegin==============================================================
//
//	Copyright@ Institut TELECOM 2005
//		http://www.institut-telecom.fr/en_accueil.html
//	
//	This software is a GPU accelerated library for computer-vision. It 
//	supports an OPENCV-like extensible interface for easily porting OPENCV 
//	applications.
//
//
//	Contacts :
//				patrick.horain@it-sudparis.eu		
//				gpucv-developers@picoforge.int-evry.fr
//	
//	Project's Home Page :
//		https://picoforge.int-evry.fr/cgi-bin/twiki/view/Gpucv/Web/WebHome
//	
//	This software is governed by the CeCILL-B license under French law and
//	abiding by the rules of distribution of free software.  You can  use, 
//	modify and/ or redistribute the software under the terms of the CeCILL-B
//	license as circulated by CEA, CNRS and INRIA at the following URL
//	"http://www.cecill.info/licences/Licence_CeCILL-B_V1-en.html". 
//	
//================================================================CVG_LicenseEnd
#include "StdAfx.h"
#include <GPUCVSwitch/switch.h>
#include <GPUCVSwitch/Cl_Dll.h>
#include <GPUCVSwitch/macro.h>
#include <GPUCVTexture/DataContainer.h>
#include <GPUCVSwitch/Cl_FctSw_Mngr.h>
#include <GPUCVCore/coretools.h>

//include files that will be generated by the switch....eggs and chicken issue here...
//#include <cxcore_switch/cxcore_switch.h>
//#include <cv_switch/cv_switch.h>
//#include <highgui_switch/highgui_switch.h>

using namespace GCV;

/*====================================*/
void cvg_switch_RegisterTracerSingletons(SG_TRC::TTCL_APPLI_TRACER<SG_TRC::SG_TRC_Default_Trc_Type> * _pAppliTracer, SG_TRC::CL_TRACING_EVENT_LIST *_pEventList)
{
	SG_TRC::TTCL_APPLI_TRACER<SG_TRC::SG_TRC_Default_Trc_Type>::Instance().RegisterNewSingleton(_pAppliTracer);
	SG_TRC::CL_TRACING_EVENT_LIST::Instance().RegisterNewSingleton(_pEventList);

#if 0
	//look into switch libraries to init singletons...
	cvg_cv_switch_RegisterTracerSingletons(_pAppliTracer, _pEventList);
	cvg_cxcore_switch_RegisterTracerSingletons(_pAppliTracer, _pEventList);
	cvg_highgui_switch_RegisterTracerSingletons(_pAppliTracer, _pEventList);
#endif
}
/*====================================*/

//=====================================
void cvgswInit(bool InitGLContext/*=true*/, bool isMultiThread/*=false*/)
{
	static bool STC_SWITCH_INIT_DONE = false;
	if(STC_SWITCH_INIT_DONE==true)
		return;

	GCV::GpuCVInit(InitGLContext, isMultiThread);

	//init singleton managers
	DllManager::GetSingleton();
	//all dll have been loaded, we init them one by one by calling function cv*DLLInit()
	DllManager::GetSingleton()->InitAllLibs(InitGLContext, isMultiThread);

	//	DllManager::RegisterSingleton(new DllManager());//read file "gcv_dlls.xml"
	CL_FctSw_Mngr::GetSingleton();
	//	CL_FctSw_Mngr::RegisterSingleton(new CL_FctSw_Mngr()); //read file "gcv_FctSwManager.xml"

	
	//set default option for some objects
	unsigned long int DataContainerOpt = 0;//DataContainer::PRESERVE_MEMORY;
#if 1//_GPUCV_DEBUG_MODE
	DataContainerOpt= DataContainerOpt
			//|DataContainer::SMART_TRANSFER
			//|DataContainer::PRESERVE_MEMORY
			;//|DataContainer::UBIQUITY;
#endif
	GetGpuCVSettings()->SetDefaultOption("DataContainer", DataContainerOpt, true);
	DataContainerOpt = DataContainer::CPU_RETURN;
	GetGpuCVSettings()->SetDefaultOption("DataContainer", DataContainerOpt, false);

	//set main default options...
	GetGpuCVSettings()->SetOption(GpuCVSettings::GPUCV_SETTINGS_PROFILING 
		|GpuCVSettings::GPUCV_SETTINGS_PROFILING_OPER
		|GpuCVSettings::GPUCV_SETTINGS_PROFILING_TRANSFER,1);
	//
	
	STC_SWITCH_INIT_DONE = true;
}
//=====================================
void cvgswAddLib(const std::string _lib, const std::string _prefix)
{
	DllManager::GetSingleton()->AddLib(_lib, _prefix);
}
//=====================================
void cvgswPrintFctStats(const std::string _fctName)
{
	if(!CL_FctSw_Mngr::GetSingleton())
	{
		GPUCV_WARNING("CL_FctSw_Mngr::PrintAllStatistics()=>No statistics to print.");
	}
	else
	{
		CL_FctSw * CurFct = CL_FctSw_Mngr::GetSingleton()->Find(_fctName);
		if(CurFct)
		{
			GPUCV_NOTICE("==================================================");
			GPUCV_NOTICE("Statistics for function:\t" << _fctName);
			GPUCV_NOTICE("			 (Processing)Number_____|_____AmntOfTimeSaved \n\n");
			GPUCV_NOTICE(CurFct->GetValStr());
			GPUCV_NOTICE("==================================================");
		}
	}
}
//=================================================
int cvgswGetLastCalledImpl(const std::string & _fctName)
{
	if(!CL_FctSw_Mngr::GetSingleton())
	{
		GPUCV_WARNING("CL_FctSw_Mngr::PrintAllStatistics()=>No statistics to print.");
	}
	else
	{
		CL_FctSw * CurFct = CL_FctSw_Mngr::GetSingleton()->Find(_fctName);
		if(CurFct)
		{
			return (int)CurFct->GetLastCalledImpl()->m_baseImplID;
		}	
	}
	return -1;
}
//=====================================
void cvgswPrintAllFctStats()
{
	if(!CL_FctSw_Mngr::GetSingleton())
	{
		GPUCV_WARNING("CL_FctSw_Mngr::PrintAllStatistics()=>No statistics to print.");
	}
	else
		CL_FctSw_Mngr::GetSingleton()->PrintAllStatistics();
}
//=====================================
void cvgswSetGlobalImplementation(BaseImplementation _impl)
{
	if(!CL_FctSw_Mngr::GetSingleton())
	{
		GPUCV_WARNING("cvgswSetGlobalImplementation() Could not force implementation.");
	}
	else
		CL_FctSw_Mngr::GetSingleton()->SetGlobalForcedImplemID(_impl);
}
//=====================================
int cvgswGetGlobalImplementation()
{
	if(!CL_FctSw_Mngr::GetSingleton())
	{	
		GPUCV_WARNING("cvgswGetGlobalImplementation() Could not get implementation.");
		return 0;
	}
	else
		return CL_FctSw_Mngr::GetSingleton()->GetGlobalForcedImplemID();
}
//=====================================
bool cvgswSetFctLastExecutionState(const char* _pFctName, const char * _pParameterSet, SG_TRC::ExecState _State)
{
	SG_Assert(_pFctName, "Empty function name");
	SG_Assert(_pParameterSet, "Empty parameter set");

	GPUCV_SWITCH_LOG("cvgswSetFctLastExecutionState("<< _pFctName << ", "<< _pParameterSet << ", "<< SGE::ToCharStr(_State) << ")");
	GET_FCTMNGR_MUTEX(MutexFctMngr);
	SG_TRC::CL_FUNCT_TRC<SG_TRC::CL_TimerVal> *pFctTracer = MutexFctMngr->Get(_pFctName);
	if(pFctTracer)
	{
		SG_TRC::CL_TRACER_RECORD<SG_TRC::CL_TimerVal> * pFctRecord=pFctTracer->TracerRecorded->Find(_pParameterSet);
		if(pFctRecord)
		{
			pFctRecord->SetExecutionState(_State);
			return true;
		}
	}
	return false;
}
//=====================================
